import ModuleHeader from "../../../ModuleHeader";

{/* lint disable no-duplicate-headings */}

{/* eslint-disable import/order */}

<ModuleHeader name="kube_redis_sentinel" sourceHref="https://github.com/Panfactum/stack/tree/__PANFACTUM_VERSION_EDGE__/packages/infrastructure/kube_redis_sentinel" status="stable" type="submodule" />

# Redis with Sentinel

import MarkdownAlert from "@/components/markdown/MarkdownAlert";

This module deploys a highly-available set of [Redis](https://redis.io/docs/) nodes.

This is deployed in a single master, many replica configuration. Failover is handled
by [Redis Sentinel](https://redis.io/docs/management/sentinel/) which is also
deployed by this module.

## Usage

### Persistence

Redis provides two mechanisms for persistence:
[AOF and RDB](https://redis.io/docs/latest/operate/oss_and_stack/management/persistence/).
This module uses RDB by default (tuned via `redis_save`).

Using AOF (whether independently or concurrently with RDB) negates the ability to do [partial resynchronizations after restarts
and failovers](https://redis.io/docs/latest/operate/oss_and_stack/management/replication/#partial-sync-after-restarts-and-failovers). Instead, a copy of the database must be transferred from the current master to restarted or new replicas. This greatly increases
the time-to-recover as well as incurs a high network cost. In fact, there is arguably no benefit to AOF-based persistence
at all with our replicated architecture as new Redis nodes will always pull their data from the running master, not
from their local AOF. The only benefit would be if *all* Redis nodes simultaneously failed with
a non-graceful shutdown (an incredibly unlikely scenario).

Persistence is always enabled in this module for similar reasons. Without persistence, an entire copy of the database would
have to be transferred from the master to each replica on every Redis node restart. The cost of storing
data on disk is far less than the network costs associated with this transfer. Moreover, persistence should
never impact performance as writes are completed asynchronously.

### Disruptions

By default, failovers of Redis pods in this module can be initiated at any time. This enables the cluster to automatically
perform maintenance operations such as instance resizing, AZ re-balancing, version upgrades, etc. However, every time a Redis pod
is disrupted, a short period of downtime might occur if the disrupted
pod is the master instance.

While this can generally be mitigated when using a [Sentinel-aware client](https://redis.io/docs/latest/develop/reference/sentinel-clients/),
you may want to provide more control over when these failovers can occur, so we provide the following options:

#### Disruption Windows

Disruption windows provide the ability to confine disruptions to specific time intervals (e.g., periods of low load) if this is needed
to meet your stability goals. You can enable this feature by setting `voluntary_disruption_window_enabled` to `true`.

The disruption windows are scheduled via `voluntary_disruption_window_cron_schedule` and the length of time of each
window via `voluntary_disruption_window_seconds`.

If you use this feature, we *strongly* recommend that you allow disruptions at least once per day, and ideally more frequently.

For more information on how this works, see the
[kube\_disruption\_window\_controller](/docs/edge/reference/infrastructure-modules/submodule/kubernetes/kube_disruption_window_controller)
submodule.

#### Custom PDBs

Rather than time-based disruption windows, you may want more granular control of when disruptions are allowed and disallowed.

You can do this by managing your own [PodDisruptionBudgets](https://kubernetes.io/docs/tasks/run-application/configure-pdb/).
This module provides outputs that will allow you to match certain subsets of Redis pods.

For example:

```hcl
module "redis" {
  source = "github.com/Panfactum/stack.git//packages/infrastructure/kube_redis_sentinel?ref=__PANFACTUM_VERSION_EDGE__" # pf-update
  ...
}

resource "kubectl_manifest" "pdb" {
  yaml_body = yamlencode({
    apiVersion = "policy/v1"
    kind       = "PodDisruptionBudget"
    metadata = {
      name      = "custom-pdb"
      namespace = module.redis.namespace
    }
    spec = {
      unhealthyPodEvictionPolicy = "AlwaysAllow"
      selector = {
        matchLabels = module.redis.match_labels_master # Selects only the Redis master (writable) pod
      }
      maxUnavailable = 0 # Prevents any disruptions
    }
  })
  force_conflicts   = true
  server_side_apply = true
}
```

While this example is constructed via IaC, you can also create / destroy these PDBs directly in your application
logic via YAML manifests and the Kubernetes API. This would allow you to create a PDB prior to initiating a long-running
operation that you do not want disrupted and then delete it upon completion.

#### Completely Disabling Voluntary Disruptions

Allowing the cluster to periodically initiate failovers of Redis is critical to maintaining system health. However,
there are rare cases where you want to override the safe behavior and disable voluntary disruptions altogether. Setting
the `voluntary_disruptions_enabled` to `false` will set up PDBs that disallow any voluntary disruption of any Redis
pod in this module.

This is *strongly* discouraged. If limiting any and all potential disruptions is of primary importance you should instead:

* Create a one-hour weekly disruption window to allow *some* opportunity for automatic maintenance operations
* Ensure that `spot_instances_enabled` and `burstable_instances_enabled` are both set to `false`
* Connect with a Sentinel-aware client
* Set `enhanced_ha_enabled` to `true`

Note that the above configuration will significantly increase the costs of running the Redis cluster (2.5-5x) versus more
flexible settings. In the vast majority of cases, this is entirely unnecessary, so this should only be used as a last resort.

<MarkdownAlert severity="warning">
  Enabling PDBs either manually or via disruption windows will not prevent all forms of disruption, only *voluntary* ones. A voluntary
  disruption is one that is done through the [Eviction API](https://kubernetes.io/docs/concepts/scheduling-eviction/api-eviction/)
  and limited by the use of PDBs.

  An example of a non-voluntary disruption would be via spot node termination or resource constraints. As a result,
  you should still implement defensive coding practices in your client code to account for potential disruptions.
</MarkdownAlert>

### Extra Redis Configuration

You can add extra Redis configuration flags via the `redis_flags` module variable.

These flags are passed as commandline arguments to the redis servers. This ensures they
will be of the highest precedence.

For more information about passing flags through the commandline and available options,
see [this documentation](https://redis.io/docs/latest/operate/oss_and_stack/management/config/).

## Providers

The following providers are needed by this module:

* [aws](https://registry.terraform.io/providers/hashicorp/aws/5.39.1/docs) (5.39.1)

* [kubectl](#requirement_kubectl) (2.0.4)

* [kubernetes](https://registry.terraform.io/providers/hashicorp/kubernetes/2.27.0/docs) (2.27.0)

* [random](https://registry.terraform.io/providers/hashicorp/random/3.6.0/docs) (3.6.0)

* [vault](https://registry.terraform.io/providers/hashicorp/vault/3.25.0/docs) (3.25.0)

## Required Inputs

The following input variables are required:

### <a name="input_namespace" /> [namespace](#input_namespace)

Description: The namespace to deploy to the redis instances into

Type: `string`

## Optional Inputs

The following input variables are optional (have default values):

### <a name="input_arm_instances_enabled" /> [arm\_instances\_enabled](#input_arm_instances_enabled)

Description: Whether the database nodes can be scheduled on arm64 instances

Type: `bool`

Default: `false`

### <a name="input_burstable_instances_enabled" /> [burstable\_instances\_enabled](#input_burstable_instances_enabled)

Description: Whether the database nodes can be scheduled on burstable instances

Type: `bool`

Default: `false`

### <a name="input_enhanced_ha_enabled" /> [enhanced\_ha\_enabled](#input_enhanced_ha_enabled)

Description: Whether to add extra high-availability scheduling constraints at the trade-off of increased cost

Type: `bool`

Default: `true`

### <a name="input_helm_version" /> [helm\_version](#input_helm_version)

Description: The version of the bitnami/redis helm chart to use

Type: `string`

Default: `"19.0.2"`

### <a name="input_lfu_cache_enabled" /> [lfu\_cache\_enabled](#input_lfu_cache_enabled)

Description: Whether redis will be deployed as an LFU cache

Type: `bool`

Default: `false`

### <a name="input_minimum_memory_mb" /> [minimum\_memory\_mb](#input_minimum_memory_mb)

Description: The minimum memory in Mb to use for the redis nodes

Type: `number`

Default: `25`

### <a name="input_monitoring_enabled" /> [monitoring\_enabled](#input_monitoring_enabled)

Description: Whether to allow monitoring CRs to be deployed in the namespace

Type: `bool`

Default: `false`

### <a name="input_panfactum_scheduler_enabled" /> [panfactum\_scheduler\_enabled](#input_panfactum_scheduler_enabled)

Description: Whether to use the Panfactum pod scheduler with enhanced bin-packing

Type: `bool`

Default: `false`

### <a name="input_persistence_backups_enabled" /> [persistence\_backups\_enabled](#input_persistence_backups_enabled)

Description: Whether to enable backups of the Redis durable storage.

Type: `bool`

Default: `true`

### <a name="input_persistence_size_gb" /> [persistence\_size\_gb](#input_persistence_size_gb)

Description: How many GB to initially allocate for persistent storage (will grow automatically as needed)

Type: `number`

Default: `1`

### <a name="input_persistence_storage_increase_gb" /> [persistence\_storage\_increase\_gb](#input_persistence_storage_increase_gb)

Description: The amount of GB to increase storage by if free space drops below the threshold

Type: `number`

Default: `1`

### <a name="input_persistence_storage_increase_threshold_percent" /> [persistence\_storage\_increase\_threshold\_percent](#input_persistence_storage_increase_threshold_percent)

Description: Dropping below this percent of free storage will trigger an automatic increase in storage size

Type: `number`

Default: `20`

### <a name="input_persistence_storage_limit_gb" /> [persistence\_storage\_limit\_gb](#input_persistence_storage_limit_gb)

Description: The maximum number of gigabytes of storage to provision for each redis node

Type: `number`

Default: `null`

### <a name="input_pull_through_cache_enabled" /> [pull\_through\_cache\_enabled](#input_pull_through_cache_enabled)

Description: Whether to use the ECR pull through cache for the deployed images

Type: `bool`

Default: `false`

### <a name="input_redis_flags" /> [redis\_flags](#input_redis_flags)

Description: Extra configuration flags to pass to each redis node

Type: `list(string)`

Default: `[]`

### <a name="input_redis_save" /> [redis\_save](#input_redis_save)

Description: Sets the save option for periodic snapshotting

Type: `string`

Default: `"300 100"`

### <a name="input_replica_count" /> [replica\_count](#input_replica_count)

Description: The number of redis replicas to deploy

Type: `number`

Default: `3`

### <a name="input_spot_instances_enabled" /> [spot\_instances\_enabled](#input_spot_instances_enabled)

Description: Whether the database nodes can be scheduled on spot instances

Type: `bool`

Default: `false`

### <a name="input_voluntary_disruption_window_cron_schedule" /> [voluntary\_disruption\_window\_cron\_schedule](#input_voluntary_disruption_window_cron_schedule)

Description: The times when disruption windows should start

Type: `string`

Default: `"0 4 * * *"`

### <a name="input_voluntary_disruption_window_enabled" /> [voluntary\_disruption\_window\_enabled](#input_voluntary_disruption_window_enabled)

Description: Whether to confine voluntary disruptions of pods in this module to specific time windows

Type: `bool`

Default: `false`

### <a name="input_voluntary_disruption_window_seconds" /> [voluntary\_disruption\_window\_seconds](#input_voluntary_disruption_window_seconds)

Description: The length of the disruption window in seconds

Type: `number`

Default: `3600`

### <a name="input_voluntary_disruptions_enabled" /> [voluntary\_disruptions\_enabled](#input_voluntary_disruptions_enabled)

Description: Whether to enable voluntary disruptions of pods in this module.

Type: `bool`

Default: `true`

### <a name="input_vpa_enabled" /> [vpa\_enabled](#input_vpa_enabled)

Description: Whether the VPA resources should be enabled

Type: `bool`

Default: `false`

## Outputs

The following outputs are exported:

### <a name="output_admin_role" /> [admin\_role](#output_admin_role)

Description: The Vault role used to get admin credentials for the created Redis cluster

### <a name="output_master_set" /> [master\_set](#output_master_set)

Description: The value for the master set to use when configuring Sentinel-aware Redis clients

### <a name="output_match_labels" /> [match\_labels](#output_match_labels)

Description: A label selector that matches all Redis pods in the cluster

### <a name="output_match_labels_master" /> [match\_labels\_master](#output_match_labels_master)

Description: A label selector that matches only the Redis master pod in the cluster

### <a name="output_namespace" /> [namespace](#output_namespace)

Description: Kubernetes namespace where module resources are created

### <a name="output_reader_role" /> [reader\_role](#output_reader_role)

Description: The Vault role used to get read-only credentials for the created Redis cluster

### <a name="output_redis_host" /> [redis\_host](#output_redis_host)

Description: A service address that points to all Redis nodes

### <a name="output_redis_host_list" /> [redis\_host\_list](#output_redis_host_list)

Description: A list of domain names for every Redis pod in the cluster

### <a name="output_redis_master_host" /> [redis\_master\_host](#output_redis_master_host)

Description: A service address that points to only the writable redis master

### <a name="output_redis_port" /> [redis\_port](#output_redis_port)

Description: The port that the Redis servers listen on

### <a name="output_redis_sentinel_host" /> [redis\_sentinel\_host](#output_redis_sentinel_host)

Description: A service address that points to the Redis Sentinels

### <a name="output_redis_sentinel_port" /> [redis\_sentinel\_port](#output_redis_sentinel_port)

Description: The port that the Sentinel servers listen on

### <a name="output_superuser_name" /> [superuser\_name](#output_superuser_name)

Description: The name of the superuser of the database

### <a name="output_superuser_password" /> [superuser\_password](#output_superuser_password)

Description: The password for root user of the database

### <a name="output_superuser_role" /> [superuser\_role](#output_superuser_role)

Description: The Vault role used to get superuser credentials for the created Redis cluster

## Usage

No notes

{/* eslint-enable import/order */}

{/* lint enable no-duplicate-headings */}
