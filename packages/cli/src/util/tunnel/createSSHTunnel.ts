import { join } from 'path';
import { z } from 'zod';
import { CLIError, PanfactumZodError } from '@/util/error/error.js';
import { fileExists } from '@/util/fs/fileExists.js';
import { removeFile } from '@/util/fs/removeFile.js';
import { writeFile } from '@/util/fs/writeFile.js';
import { execute } from '@/util/subprocess/execute.js';
import { getVaultToken } from '@/util/vault/getVaultToken.js';
import type { PanfactumContext } from '@/util/context/context.js';

/**
 * Schema for validating network port numbers in SSH tunnel configurations
 * 
 * @remarks
 * This schema enforces strict port number validation for SSH tunnel operations,
 * ensuring secure and valid network connections. Port validation is critical
 * for preventing connection hijacking, privilege escalation, and network
 * misconfigurations in Panfactum's SSH tunneling system.
 * 
 * **Security constraints enforced:**
 * - Port range 1-65535: Validates against the full valid TCP/UDP port range
 * - Integer validation: Prevents floating point ports that could cause connection errors
 * - Non-zero validation: Port 0 is reserved and not usable for connections
 * 
 * **Why these constraints matter:**
 * - Ports 1-1023: System/privileged ports, require elevated permissions
 * - Ports 1024-49151: User/registered ports, safe for application use
 * - Ports 49152-65535: Dynamic/private ports, often used for ephemeral connections
 * - Invalid ports (>65535): Would cause network stack errors and connection failures
 * 
 * **Common validation failures:**
 * - Port 0: Reserved system port
 * - Negative ports: Invalid network configuration
 * - Ports >65535: Exceed maximum port range
 * - Floating point numbers: Not valid for network sockets
 * 
 * **Integration context:**
 * Used by SSH tunnel creation to validate both local forwarding ports and
 * remote target ports. Prevents misconfigurations that could expose services
 * on unintended interfaces or cause connection routing errors.
 * 
 * @example
 * ```typescript
 * // Valid ports
 * portSchema.parse(8080);  // Application port
 * portSchema.parse(5432);  // PostgreSQL default
 * portSchema.parse(443);   // HTTPS port
 * 
 * // Invalid ports (will throw)
 * portSchema.parse(0);      // Reserved
 * portSchema.parse(70000);  // Out of range
 * portSchema.parse(-1);     // Negative
 * ```
 * 
 * @see {@link createSSHTunnel} - For SSH tunnel creation using validated ports
 * @see {@link connectionInfoLineSchema} - For parsing bastion connection data
 */
export const portSchema = z.number().int().min(1).max(65535)
  .describe("Network port number (1-65535)");

export interface ISSHTunnelOptions {
  context: PanfactumContext;
  bastionName: string;
  remoteAddress: string;
  localPort: number;
  vaultAddress: string;
}

export interface ISSHTunnelHandle {
  pid: number;
  localPort: number;
  remoteAddress: string;
  bastionName: string;
  close: () => Promise<void>;
}

export async function createSSHTunnel(options: ISSHTunnelOptions): Promise<ISSHTunnelHandle> {
  const {
    context,
    bastionName,
    remoteAddress,
    localPort,
    vaultAddress
  } = options;

  // Get SSH directory from context
  const sshDir = context.devshellConfig.ssh_dir;

  // Read connection info to get bastion details
  const connectionInfoFile = join(sshDir, 'connection_info');
  if (!(await fileExists({ filePath: connectionInfoFile }))) {
    throw new CLIError(
      `Connection info file not found at ${connectionInfoFile}. Run pf devshell sync to generate it.`
    );
  }

  /**
   * Schema for parsing and validating SSH bastion connection information
   * 
   * @remarks
   * This schema validates the connection info file format used by Panfactum's
   * SSH bastion infrastructure. Each line represents a bastion host with its
   * connection details, enabling secure tunneling to internal resources.
   * 
   * **Format constraints enforced:**
   * - Exactly 3 space-separated fields: `name domain port`
   * - Non-empty bastion name: Prevents connection to undefined hosts
   * - Valid domain format: Ensures proper DNS resolution
   * - Numeric port format: Must be valid integers in port range
   * 
   * **Why these constraints matter:**
   * - Format consistency: Ensures reliable parsing across environments
   * - Security validation: Prevents injection of malicious connection data
   * - Connection reliability: Invalid domains/ports cause tunnel failures
   * - Infrastructure integrity: Malformed data could expose internal networks
   * 
   * **Data source context:**
   * The connection info file is generated by `pf devshell sync` and contains
   * bastion host details discovered from the Panfactum infrastructure. This
   * schema validates that the file format matches expectations and prevents
   * connection attempts to malformed or potentially malicious targets.
   * 
   * **Common validation failures:**
   * - Wrong field count: Missing or extra fields in connection string
   * - Empty fields: Blank bastion names, domains, or ports
   * - Invalid port format: Non-numeric or out-of-range port numbers
   * - Malformed domains: Domains that won't resolve or are invalid
   * 
   * **Security implications:**
   * - Prevents SSH connection to arbitrary hosts
   * - Validates against connection info file tampering
   * - Ensures only approved bastion hosts are accessible
   * - Blocks injection attacks through malformed connection data
   * 
   * @example
   * ```typescript
   * // Valid connection info line
   * const result = connectionInfoLineSchema.parse("prod-bastion example.com 22");
   * // Result: { name: "prod-bastion", domain: "example.com", port: 22 }
   * 
   * // Invalid formats (will throw)
   * connectionInfoLineSchema.parse("bastion");           // Missing fields
   * connectionInfoLineSchema.parse("bastion domain");    // Missing port
   * connectionInfoLineSchema.parse("bastion domain abc"); // Invalid port
   * connectionInfoLineSchema.parse(" domain 22");        // Empty name
   * ```
   * 
   * @see {@link portSchema} - For port number validation
   * @see {@link createSSHTunnel} - For tunnel creation using validated connection data
   */
  const connectionInfoLineSchema = z.string()
    .transform((line) => {
      const parts = line.split(' ');
      if (parts.length !== 3) {
        throw new Error('Invalid format');
      }
      return {
        name: parts[0],
        domain: parts[1],
        port: parts[2]
      };
    })
    .pipe(z.object({
      /** Bastion host identifier (must be non-empty) */
      name: z.string().min(1).describe("Bastion host name"),
      /** DNS domain for bastion host connection */
      domain: z.string().min(1).describe("Bastion host domain"),
      /** SSH port for bastion connection (numeric string converted to validated port) */
      port: z.string().regex(/^\d+$/).transform(Number).pipe(portSchema).describe("SSH port number")
    }))
    .describe("SSH bastion connection information parser");

  const connectionInfo = await Bun.file(connectionInfoFile).text()
    .catch((error: unknown) => {
      throw new CLIError(
        `Failed to read connection info from ${connectionInfoFile}`,
        error
      );
    });

  const bastionLine = connectionInfo.split('\n').find(line => line.startsWith(`${bastionName} `));

  if (!bastionLine) {
    throw new CLIError(
      `${bastionName} not found in ${connectionInfoFile}. Ensure this name is correct or run pf devshell sync to regenerate this file.`
    );
  }

  // Parse connection data synchronously
  const parseResult = connectionInfoLineSchema.safeParse(bastionLine);
  if (!parseResult.success) {
    throw new PanfactumZodError(
      `Invalid connection info format for ${bastionName}`,
      connectionInfoFile,
      parseResult.error
    );
  }
  const connectionData = parseResult.data;
  const bastionDomain = connectionData.domain;
  const bastionPort = connectionData.port.toString();

  // Setup SSH keys
  const keyFile = join(sshDir, `id_ed25519_${bastionName}`);
  const publicKeyFile = `${keyFile}.pub`;
  const signedPublicKeyFile = `${keyFile}_signed.pub`;

  // Generate keys if they don't exist
  if (!(await fileExists({ filePath: keyFile })) || !(await fileExists({ filePath: publicKeyFile })) || !(await fileExists({ filePath: signedPublicKeyFile }))) {
    context.logger.info('Generating SSH keys...');

    // Clean up any partial keys
    for (const file of [keyFile, publicKeyFile, signedPublicKeyFile]) {
      if (await fileExists({ filePath: file })) {
        await removeFile({ filePath: file });
      }
    }

    // Generate new keys
    await execute({
      command: [
        'ssh-keygen',
        '-q',
        '-t', 'ed25519',
        '-N', '',
        '-C', bastionName,
        '-f', keyFile
      ],
      context,
      workingDirectory: process.cwd(),
    }).catch((error: unknown) => {
      throw new CLIError(
        `Failed to generate SSH keys for ${bastionName}`,
        error
      );
    });
  }

  // Sign SSH key with Vault
  const vaultToken = await getVaultToken({ context, address: vaultAddress });

  const result = await execute({
    command: [
      'vault',
      'write',
      '-field',
      'signed_key',
      'ssh/sign/default',
      `public_key=@${publicKeyFile}`
    ],
    context,
    workingDirectory: process.cwd(),
    env: {
      ...process.env,
      VAULT_ADDR: vaultAddress,
      VAULT_TOKEN: vaultToken
    }
  }).catch((error: unknown) => {
    throw new CLIError(
      `Failed to sign SSH key with Vault for ${bastionName}`,
      error
    );
  });

  const signedKey = result.stdout;

  if (!signedKey || signedKey.trim().length === 0) {
    throw new CLIError(
      `Vault returned empty signed key for ${bastionName}`
    );
  }

  context.logger.info('SSH Key signed successfully');
  await writeFile({
    context,
    filePath: signedPublicKeyFile,
    contents: signedKey,
    overwrite: true
  }).catch((error: unknown) => {
    throw new CLIError(
      `Failed to write signed SSH key to ${signedPublicKeyFile}`,
      error
    );
  });

  // Establish tunnel using execute with background mode
  const knownHostsFile = join(sshDir, 'known_hosts');

  const tunnelResult = await execute({
    command: [
      'autossh',
      '-M', '0',
      '-o', `UserKnownHostsFile=${knownHostsFile}`,
      '-o', 'IdentitiesOnly=yes',
      '-o', 'IdentityAgent=none',
      '-o', 'ServerAliveInterval=2',
      '-o', 'ServerAliveCountMax=3',
      '-o', 'ConnectTimeout=1',
      '-N',
      '-i', keyFile,
      '-i', signedPublicKeyFile,
      '-L', `127.0.0.1:${localPort}:${remoteAddress}`,
      '-p', bastionPort,
      `panfactum@${bastionDomain}`
    ],
    context,
    workingDirectory: process.cwd(),
    env: {
      ...process.env,
      AUTOSSH_GATETIME: '0'
    },
    background: true,
    backgroundDescription: `SSH tunnel to ${remoteAddress} via ${bastionName}`
  }).catch((error: unknown) => {
    throw new CLIError(
      `Failed to establish SSH tunnel to ${remoteAddress} via ${bastionName}`,
      error
    );
  });

  if (!tunnelResult.pid) {
    throw new CLIError('Failed to start SSH tunnel - no process ID returned');
  }

  context.logger.info(
    `Tunnel established: localhost:${localPort} → ${remoteAddress} via ${bastionName}`
  );

  // Return handle for managing the tunnel
  return {
    pid: tunnelResult.pid,
    localPort,
    remoteAddress,
    bastionName,
    close: async () => {
      context.logger.info('Closing tunnel...');
      await context.backgroundProcessManager.killProcess({
        pid: tunnelResult.pid,
        killChildren: true
      });
    }
  };
}