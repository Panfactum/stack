#################################################################
## DO NOT EDIT - This file is automatically generated.
#################################################################

locals {

  ############################################################################################
  # Variable Resolution
  #
  # Load all the terragrunt variables
  # For more information about the configuration architecture and available options,
  # see https://panfactum.com/docs/edge/reference/configuration/terragrunt-variables
  ############################################################################################

  vars         = jsondecode(run_cmd("--terragrunt-quiet", "pf", "config", "get"))
  extra_inputs = local.vars.extra_inputs
  extra_tags   = local.vars.extra_tags

  ############################################################################################
  # Provider Activation
  ############################################################################################

  # Activated providers
  lockfile_contents    = try(file(find_in_parent_folders("${get_original_terragrunt_dir()}/.terraform.lock.hcl")), "")
  enable_aws           = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/aws")
  enable_kubernetes    = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/kubernetes")
  enable_kubectl       = strcontains(local.lockfile_contents, "registry.opentofu.org/alekc/kubectl")
  enable_mongodb_atlas = strcontains(local.lockfile_contents, "registry.opentofu.org/mongodb/mongodbatlas")
  enable_vault         = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/vault")
  enable_helm          = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/helm")
  enable_authentik     = strcontains(local.lockfile_contents, "registry.opentofu.org/goauthentik/authentik")
  enable_time          = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/time")
  enable_local         = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/local")
  enable_random        = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/random")
  enable_tls           = strcontains(local.lockfile_contents, "registry.opentofu.org/hashicorp/tls")
  enable_pf            = strcontains(local.lockfile_contents, "registry.opentofu.org/panfactum/pf")


  ############################################################################################
  # Shared module logic
  ############################################################################################

  # The module to deploy - This logic is used BOTH for Panfactum modules and first-party IaC
  module = lookup(local.vars, "module", basename(get_original_terragrunt_dir()))

  # Inspect the terragrunt.hcl that includes this shared file. If it uses the 'pf_stack_source'
  # local, that means it is almost certainly deploying a Panfactum module directly (vs a first-party IaC module)
  is_pf_stack_module = strcontains(file("${get_original_terragrunt_dir()}/terragrunt.hcl"), "pf_stack_source")

  ############################################################################################
  # How to source the Panfactum modules
  ############################################################################################

  # Constant for the git repository where Panfactum modules live
  pf_stack_repo = "github.com/panfactum/stack"

  # The version of the Panfactum modules to use ("local" means use the local copy)
  pf_stack_version = lookup(local.vars, "pf_stack_version", "main")

  # Whether to use the local copy of the Panfactum modules -- useful for debugging and local
  # development of module updates.
  use_local_pf_modules = local.pf_stack_version == "local"

  # Long commit sha for the specific branch / tag / commit specified
  pf_stack_version_commit_hash = run_cmd("--terragrunt-global-cache", "--terragrunt-quiet", "pf-get-commit-hash", "--ref=${local.pf_stack_version}", "--repo=https://${local.pf_stack_repo}")

  # The absolute path on the machine to the local copy of the Panfactum modules
  # If pf_stack_local_path isn't set, we assume that the we are in the reference repository (note that we use get_repo_root() vs local.repo_root to get the actual git repo root)
  pf_stack_local_absolute_path = lookup(local.vars, "pf_stack_local_path", get_repo_root())

  # This is used for cache invalidation since we cannot use git refs for the local copy
  pf_stack_local_ref = local.use_local_pf_modules ? run_cmd("--terragrunt-global-cache", "--terragrunt-quiet", "pf-get-local-module-hash", local.use_local_pf_modules ? "${local.pf_stack_local_absolute_path}/packages/infrastructure" : "") : ""

  # We can either choose to use relative or absolute file paths for sourcing local module versions
  # We default to using relative b/c this adds enhanced cache invalidation logic
  pf_stack_local_use_relative = lookup(local.vars, "pf_stack_local_use_relative", true)

  # The relative path from the local.repo_root to the local copy of the Panfactum modules
  pf_stack_local_relative_path_from_root = run_cmd("--terragrunt-global-cache", "--terragrunt-quiet", "realpath", "--relative-to=${local.repo_root}", local.pf_stack_local_absolute_path)

  # The relative path from the module's terragrunt.hcl directory to the local copy of the Panfactum modules
  pf_stack_local_relative_path_from_tg_dir = run_cmd("--terragrunt-global-cache", "--terragrunt-quiet", "realpath", "--relative-to=${get_original_terragrunt_dir()}", local.pf_stack_local_absolute_path)

  # The relative path from the directory where tf is actually run (in .terragrunt-cache) to the local copy of the Panfactum modules
  # Note that this will change depending on whether the first-party IaC modules are themselves using local code or if they are pulling from the remote git repo
  # TODO: update when https://github.com/gruntwork-io/terragrunt/issues/3896 is resolved
  pf_stack_local_relative_path_from_working_dir = "${local.use_local_iac ? "../../../.." : "../../../../${join("/", [for segment in split("/", local.vars.local.vars.iac_relative_dir) : ".."])}"}/${local.pf_stack_local_relative_path_from_root}"

  # The terraform.source to use if deploying a "direct" Panfactum module (i.e., not a submodule)
  # TODO: It is unclear to me why we don't support relative paths here, so let's investigate in the future.
  pf_stack_source = local.use_local_pf_modules ? ("${local.pf_stack_local_absolute_path}/packages/infrastructure//${local.module}") : "https://modules.panfactum.com/${local.pf_stack_version_commit_hash}/modules.tar.gz//${local.module}"

  ############################################################################################
  # Repo metadata
  ############################################################################################
  repo_url               = local.vars.repo_url
  repo_authentication    = try("${get_env("GIT_USERNAME")}${try(":${get_env("GIT_PASSWORD")}", "")}@", "")
  authenticated_repo_url = "git::https://${local.repo_authentication}${trimprefix(local.repo_url, "git::https://")}"
  repo_name              = local.vars.repo_name
  repo_root              = local.vars.repo_root
  primary_branch         = local.vars.repo_primary_branch

  ############################################################################################
  # How to source first-party IaC modules
  ############################################################################################

  # Determine the module "version" (git ref to checkout)
  # Use the following priority ordering:
  # 1. The `version` key in any of the `yaml` files
  # 2. Fallback to the repo's primary branch
  version = lookup(local.vars, "version", local.primary_branch)

  # Long commit sha for the specific branch / tag / commit specified
  version_hash = run_cmd("--terragrunt-global-cache", "--terragrunt-quiet", "pf-get-commit-hash", "--ref=${local.version}")

  # Whether to use the local copy of the first-party IaC rather than download from the remote git repo
  # Always use the local copy if trying to deploy to mainline branches to resolve performance and caching issues
  use_local_iac = contains(["local", local.primary_branch], local.version)

  # The terraform.source for the first-party IaC
  # Note that the location of the // is intentional and changes depending on whether local or not.
  source = (
    local.use_local_iac ?
    "${local.vars.iac_dir}//${local.module}" :
    "${local.authenticated_repo_url}//${local.vars.iac_relative_dir}/${local.module}?ref=${local.version_hash}"
  )

  ############################################################################################
  # Vault Token Sourcing
  ############################################################################################

  # We have customized the retrieval of the Vault token in order to handle all the various scenarios for how modules
  # can be applied
  vault_address = local.is_ci ? get_env("VAULT_ADDR", "@@TERRAGRUNT_INVALID@@") : lookup(local.vars, "vault_addr", get_env("VAULT_ADDR", "@@TERRAGRUNT_INVALID@@"))
  vault_token = run_cmd(
    "--terragrunt-global-cache", "--terragrunt-quiet",
    "pf-get-vault-token",
    "--address", local.vault_address,
    local.enable_vault ? "" : "--noop"
  )

  ############################################################################################
  # Kubernetes Connection
  ############################################################################################
  kube_api_server     = try(local.is_ci ? try("https://${get_env("KUBERNETES_SERVICE_HOST")}", local.vars.kube_api_server) : local.vars.kube_api_server, "")
  kube_config_context = try(local.is_ci ? "ci" : local.kube_api_server == "" ? "" : local.vars.kube_config_context, "")

  ############################################################################################
  # Miscellaneous
  ############################################################################################
  # Folder of shared snippets to generate
  provider_folder = "providers"

  # local dev namespace
  # TODO: This is deprecated and will be removed / changed in a future release
  local_dev_namespace = get_env("LOCAL_DEV_NAMESPACE", "")
  is_local            = local.vars.environment == "local"


  # With Panfactum CI (and most other CI providers), the CI env variable is set to indicate the execution context is a CI runner
  is_ci = get_env("CI", "false") == "true" || get_env("CI", "false") == "1"

  # sla_target is both a provider config option and a common module input. To keep everything aligned,
  # this ensures that the provider config option will equal the module input iff the module input
  # is set via extra_inputs. We default to 3.
  # For more information on SLA targets, see https://panfactum.com/docs/edge/guides/deploying-workloads/high-availability
  sla_target = lookup(local.extra_inputs, "sla_target", lookup(local.vars, "sla_target", 3))
}

################################################################
### The main IaC source
################################################################

terraform {
  source = local.source # We default to the first-party IaC module but this should be overridden in each terragrunt.hcl

  # Force Terraform to keep trying to acquire a lock for
  # up to 30 minutes if someone else already has the lock
  extra_arguments "retry_lock" {
    commands = get_terraform_commands_that_need_locking()
    arguments = [
      local.is_local ? "-lock=false" : "-lock-timeout=30m"
    ]
  }

  # Fail fast if inputs are missing rather than prompting for
  # interactive input
  extra_arguments "input_validation" {
    commands = get_terraform_commands_that_need_input()
    arguments = [
      "-input=false",
    ]
  }


  before_hook "deploy_status" {
    commands = ["apply"]
    execute = [
      "pf",
      "iac", "update-module-status",
      "-m", get_original_terragrunt_dir(),
      "--deploy-status", "running"
    ]
  }

  after_hook "deploy_status" {
    commands = ["apply"]
    execute = [
      "pf",
      "iac", "update-module-status",
      "-m", get_original_terragrunt_dir(),
      "--deploy-status", "success"
    ]
  }

  error_hook "deploy_status" {
    commands = ["apply"]
    execute = [
      "pf",
      "iac", "update-module-status",
      "-m", get_original_terragrunt_dir(),
      "--deploy-status", "error"
    ]
    on_errors = [".*"]
  }

  before_hook "init_status" {
    commands = ["init"]
    execute = [
      "pf",
      "iac", "update-module-status",
      "-m", get_original_terragrunt_dir(),
      "--init-status", "running"
    ]
  }

  after_hook "init_status" {
    commands = ["init"]
    execute = [
      "pf",
      "iac", "update-module-status",
      "-m", get_original_terragrunt_dir(),
      "--init-status", "success"
    ]
  }

  error_hook "init_status" {
    commands = ["init"]
    execute = [
      "pf",
      "iac", "update-module-status",
      "-m", get_original_terragrunt_dir(),
      "--init-status", "error"
    ]
    on_errors = [".*"]
  }
}

################################################################
### Provider Configurations
################################################################

generate "pf_provider" {
  path        = "pf.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_pf
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/pf.tftpl", {
    is_local            = local.is_local
    environment         = local.vars.environment
    region              = local.vars.region
    stack_version       = local.pf_stack_version
    stack_commit        = local.pf_stack_version_commit_hash
    root_module         = local.module
    extra_tags          = local.extra_tags
    kube_api_server     = local.kube_api_server
    kube_config_context = local.kube_config_context
    sla_target          = local.sla_target
  })
}

generate "aws_provider" {
  path        = "aws.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_aws
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/aws.tftpl", {
    aws_region     = local.vars.aws_region
    aws_account_id = local.vars.aws_account_id
    aws_profile    = local.is_ci ? "ci" : local.vars.aws_profile
  })
}

# Note: If the aws provider is enabled, always enable the secondary as it removes a footgun at no extra cost
generate "aws_secondary_provider" {
  path        = "aws_secondary.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_aws
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/aws_secondary.tftpl", {
    aws_region     = local.vars.aws_secondary_region
    aws_account_id = local.vars.aws_secondary_account_id
    aws_profile    = local.is_ci ? "ci" : local.vars.aws_secondary_profile
  })
}

# Note: If the aws provider is enabled, always enable the global as it removes a footgun at no extra cost
generate "aws_global_provider" {
  path        = "aws_global.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_aws
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/aws_global.tftpl", {
    aws_account_id = local.vars.aws_account_id
    aws_profile    = local.is_ci ? "ci" : local.vars.aws_profile
  })
}

generate "kubernetes_provider" {
  path        = "kubernetes.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_kubernetes
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/kubernetes.tftpl", {
    kube_api_server     = local.kube_api_server
    kube_config_context = local.kube_config_context
  })
}

generate "kubectl_provider" {
  path        = "kubectl.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_kubectl
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/kubectl.tftpl", {
    kube_api_server     = local.kube_api_server
    kube_config_context = local.kube_config_context
  })
}

generate "helm_provider" {
  path        = "helm.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_helm
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/helm.tftpl", {
    kube_api_server     = local.kube_api_server
    kube_config_context = local.kube_config_context
  })
}

generate "authentik_provider" {
  path        = "authentik.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_authentik
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/authentik.tftpl", {
    authentik_url = lookup(local.vars, "authentik_url", "@@TERRAGRUNT_INVALID@@")
  })
}

generate "time_provider" {
  path        = "time.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_time
  if_disabled = "remove"
  contents    = file("${local.provider_folder}/time.tf")
}

generate "random_provider" {
  path        = "random.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_random
  if_disabled = "remove"
  contents    = file("${local.provider_folder}/random.tf")
}

generate "local_provider" {
  path        = "local.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_local
  if_disabled = "remove"
  contents    = file("${local.provider_folder}/local.tf")
}

generate "tls_provider" {
  path        = "tls.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_tls
  if_disabled = "remove"
  contents    = file("${local.provider_folder}/tls.tf")
}

generate "vault_provider" {
  path        = "vault.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_vault
  if_disabled = "remove"
  contents = templatefile("${local.provider_folder}/vault.tftpl", {
    vault_address = local.vault_address
    vault_token   = local.vault_token
  })
}

generate "mongodb_atlas_provider" {
  path      = "mongodb_atlas.tf"
  if_exists = "overwrite_terragrunt"
  contents  = local.enable_mongodb_atlas ? file("${local.provider_folder}/mongodb_atlas.tf") : ""
}

################################################################
### Provider Overrides
###
### Required b/c tf will default providers to the hashicorp namespace
### if the provider is used in a submodule but the source is not configured in the root module...
### even if the source IS specified in the submodule. I know... wtf were they thinking.
###
### As a result, we need these overrides for every provider not in the hashicorp namespace.
###
### See https://github.com/hashicorp/terraform/issues/27663
################################################################

generate "authentik_override_provider" {
  path        = "authentik_override.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_authentik || local.is_pf_stack_module # If we are deploying a Panfactum module directly, do not override as it will clear the version
  if_disabled = "remove"
  contents    = file("${local.provider_folder}/authentik_override.tf")
}

generate "kubectl_override_provider" {
  path        = "kubectl_override.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_kubectl || local.is_pf_stack_module # If we are deploying a Panfactum module directly, do not override as it will clear the version
  if_disabled = "remove"
  contents    = file("${local.provider_folder}/kubectl_override.tf")
}

generate "pf_override_provider" {
  path        = "pf_override.tf"
  if_exists   = "overwrite_terragrunt"
  disable     = !local.enable_pf || local.is_pf_stack_module # If we are deploying a Panfactum module directly, do not override as it will clear the version
  if_disabled = "remove"
  contents    = file("${local.provider_folder}/pf_override.tf")
}

################################################################
### Remote State Configuration
################################################################

remote_state {
  backend = "s3"

  generate = {
    path      = "backend.tf"
    if_exists = "overwrite_terragrunt"
  }

  config = {
    profile        = local.is_ci ? "ci" : local.vars.tf_state_profile
    bucket         = local.vars.tf_state_bucket
    key            = "${local.repo_name}/${local.is_local ? "${local.local_dev_namespace}/" : ""}${path_relative_to_include()}/terraform.tfstate"
    region         = local.vars.tf_state_region
    encrypt        = true
    dynamodb_table = local.vars.tf_state_lock_table
  }
}

################################################################
### Terragrunt Configuration
################################################################

terraform_version_constraint = "~> 1.8"
terraform_binary             = "tofu"

retryable_errors = local.is_ci ? [".*"] : [
  "(?si).*UnrecognizedClientException.*",
  "(?si).*handshake timeout.*",
  "(?si).*Authentication Failure.*",
  "(?si).*connection reset.*",
  "(?si).*connection closed.*",
  "(?si).*tcp.*timeout.*",
  "NoSuchBucket: The specified bucket does not exist",
  "(?si).*Error creating SSM parameter: TooManyUpdates:.*",
  "(?si).*429 Too Many Requests.*",
  "(?si).*Client\\.Timeout exceeded while awaiting headers.*",
  "(?si).*returned error: 429.*",
  "(?si).*inheritedMetadata.*id.*",
  "(?si).*Provider produced inconsistent final plan.*"
]
retry_max_attempts       = 3
retry_sleep_interval_sec = 30

################################################################
### Default Module Inputs
################################################################

inputs = merge(
  local.extra_inputs,
  {
    pf_module_source = local.use_local_pf_modules ? (local.pf_stack_local_use_relative ? "${local.pf_stack_local_relative_path_from_working_dir}/packages/infrastructure//" : "${local.pf_stack_local_absolute_path}/packages/infrastructure//") : "https://modules.panfactum.com/${local.pf_stack_version_commit_hash}/modules.tar.gz//"
    pf_module_ref    = local.use_local_pf_modules ? (local.pf_stack_local_use_relative ? "" : "?ref=${local.pf_stack_local_ref}") : ""
    sla_target       = local.sla_target
    route53_zones    = lookup(local.vars, "domains", {})
    kube_domain      = lookup(local.vars, "kube_domain", null)
  }
)